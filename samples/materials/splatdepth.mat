material {
    name : splat,
    parameters : [
        { type : float,    name : radiusScale },
        { type : float,    name : forwardFactor },
        { type : bool,     name : depthPrepass }
    ],
    requires : [ position, color, custom0, custom1, custom2],
    variables : [ vnormal ,vuv],
    shadingModel : unlit,
    blending : add,
    depthWrite : true,
    colorWrite : false,
    culling : none
}
vertex {
    mat3 calcRotation(vec3 Axis, float Angle)
    {
	    float c = cos(Angle);
	    float sub_c = 1.0 - c;
	    float s = sin(Angle);
	    return mat3(
		    vec3(c + pow(Axis.x, 2.0) * sub_c,
			    Axis.y * Axis.x * sub_c + Axis.z * s,
			    Axis.z * Axis.x * sub_c - Axis.y * s),
		    vec3(Axis.x * Axis.y * sub_c - Axis.z * s,
			    c + pow(Axis.y, 2.0) * sub_c,
			    Axis.z * Axis.y * sub_c + Axis.x * s),
		    vec3(Axis.x * Axis.z * sub_c + Axis.y * s,
			    Axis.y * Axis.z * sub_c - Axis.x * s,
			    c + pow(Axis.z, 2.0) * sub_c));
    }
    void materialVertex(inout MaterialVertexInputs material) {
        material.vnormal = normalize(getCustom1());
        material.vuv.xy = getCustom2().xy;

        mat3 RotMat = mat3(1.0);
        vec3 QuadNormal = vec3(0.0, 0.0, 1.0);
        float scaledRadius = getCustom0().r * materialParams.radiusScale;
        if(abs(getCustom1().xyz) != QuadNormal)
        {
            vec3 rotAxis = normalize(cross(QuadNormal, getCustom1().xyz));
            float rotAngle = acos(dot(QuadNormal, getCustom1().xyz));
            RotMat = calcRotation(rotAxis, rotAngle);
        }
        //vec3 worldPos = RotMat * scaledRadius * vec3(getCustom2().xy,0) + getPosition().xyz;
        vec3 localOffset = RotMat * scaledRadius * vec3(getCustom2().xy,0);
        vec3 worldPos = (getWorldFromModelMatrix() * vec4(getPosition().xyz, 1.0)).xyz + localOffset;
        if (materialParams.depthPrepass) {
           vec3 viewDir = normalize(worldPos - getWorldCameraPosition());
           worldPos += viewDir * scaledRadius * materialParams.forwardFactor;
        }
        material.worldPosition = vec4(worldPos, 1.0);
        //gl_Position = getClipFromWorldMatrix()*vec4(worldPos, 1.0);  
    }
}
fragment {
    void material(inout MaterialInputs material) {
        prepareMaterial(material);
        float len = length(variable_vuv.xy);
        if (len > 1.0) {
            discard;
        }
        if (!materialParams.depthPrepass) {
            float opacity = 1.0 / sqrt(2.0 * PI) * exp(-pow(len * 2.5, 2.0)/2.0);
            vec3 color = getColor().xyz;
            //vec3 normal = variable_vnormal.xyz;
            //material.normal = normal * opacity;
            //material.baseColor = vec4(1.0, 0.0, 0.0, 1.0); //test
            material.baseColor = vec4(color * opacity, opacity);
        }
        
    }
}
