material {
    name : splat,
    parameters : [
        { type : float,    name : radiusScale },
        { type : float,    name : forwardFactor },
        { type : bool,     name : depthPrepass }
    ],
    requires : [ position, color, custom0, custom1, uv0 ],
    variables : [ vnormal ],
    shadingModel : unlit,
    blending : add,
    depthWrite : true
}
vertex {
    mat3 rotationAlign(vec3 from, vec3 to) {
        vec3  v = cross(from, to);
        float c = dot(from, to);
        if (c > 0.9999) return mat3(1.0);            // 方向相同
        if (c < -0.9999) return mat3(-1.0, 0, 0, 0, -1, 0, 0, 0, 1); // 相反
        float k = 1.0 / (1.0 + c);
        return mat3(
            v.x * v.x * k + c,      v.y * v.x * k - v.z,  v.z * v.x * k + v.y,
            v.x * v.y * k + v.z,    v.y * v.y * k + c,    v.z * v.y * k - v.x,
            v.x * v.z * k - v.y,    v.y * v.z * k + v.x,  v.z * v.z * k + c);
    }
    void materialVertex(inout MaterialVertexInputs material) {
         // 计算顶点的世界位置
        vec3 worldPos = getPosition().xyz;
        // 计算法线方向
        vec3 normal = normalize(getCustom1().xyz);
        // 计算旋转矩阵
        mat3 rotMat = rotationAlign(vec3(0, 0, 1), normal);
        // 计算缩放后的半径
        float scaledRadius = getCustom0().r * materialParams.radiusScale;
        // 计算顶点的局部坐标
        vec2 quadPos = material.uv0.xy;
        //

        // 计算顶点的最终位置
        vec3 finalPos = rotMat * scaledRadius * vec3(quadPos, 0.0) + worldPos;
        // 如果处于深度预传递阶段，调整顶点位置
        if (materialParams.depthPrepass) {
            vec3 viewDir = normalize(worldPos - getWorldCameraPosition());
            finalPos += viewDir * scaledRadius * materialParams.forwardFactor;
        }

        material.worldPosition = getClipFromWorldMatrix() * vec4(finalPos, 1.0);
        // 传递法线和颜色到片段着色器
        material.vnormal = normalize(getCustom1());
    }
}
fragment {
    void material(inout MaterialInputs material) {
        float len = length(getUV0());
        if (len > 1.0) {
            discard;
        }
        if (!materialParams.depthPrepass) {
            float opacity = 1.0 / sqrt(2.0 * PI) * exp(-pow(len * 2.5, 2.0)/2.0);
            vec3 color = getColor().xyz;
            vec3 normal = variable_vnormal.xyz;
            material.normal = normal * opacity;
            //material.baseColor = vec4(1.0, 0.0, 0.0, 1.0); //test
            material.baseColor = vec4(color * opacity, opacity);
        }
        prepareMaterial(material);
    }
}
